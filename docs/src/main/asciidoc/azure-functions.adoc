////
This guide is maintained in the main Quarkus repository
and pull requests should be submitted there:
https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
////
[id="azure-functions-trigger"]

= Integrate and deploy an HTTP Trigger function to Azure Functions
:extension-status: preview
include::_attributes.adoc[]
:diataxis-type: howto
:categories: cloud,integration

Integrate your Quarkus functions with link:https://learn.microsoft.com/en-us/azure/azure-functions/[Microsoft Azure Functions] by adding the `quarkus-azure-functions` extension to your code project.
You can write HTTP functions in your Quarkus applications that integrate with, deploy, and run on Azure Functions by using the extension and link:https://quarkus.io/blog/quarkus-dependency-injection/[Quarkus ArC].
This tutorial shows an example of how a Quarkus application that includes an HTTP Trigger function can be deployed to the Azure Functions runtime.

// Diataxis: If this section grows, I propose that the following section == is moved into a reference topic that describes all Azure extensions, which is linked from here.

== About the `quarkus-azure-functions` extension

include::{includes}/extension-status.adoc[]

The `quarkus-azure-functions` extension is one of the integration points between Azure Functions and Quarkus.

`quarkus-azure-functions` provides the following capabilities for integrating your Quarkus code projects with Azure Functions.

* Interacts with the Azure Functions runtime to bootstrap Quarkus
* Registers a callback to set up link:https://quarkus.io/blog/quarkus-dependency-injection/[Quarkus ArC] as the function factory for function classes
* Turns any Azure Functions class you write into a Quarkus ArC CDI bean
* Injects any service or component initialized by Quarkus directly into your function classes

[IMPORTANT]
====
Quarkus integration with Azure Functions does not currently apply to xref:dev-mode-differences.adoc[Quarkus dev mode].
====

// Diataxis: The following section could be a step in the main procedure or later on in this topic as an advanced/option step. Doesn't make sense to be here at the beginning.
== Lifecycle of your function classes

If you want your function class to be a singleton, you can change the lifecycle of your function class from the default request-scoped to application-scoped.

.Example

[source, java]
----
import com.microsoft.azure.functions.ExecutionContext;
import com.microsoft.azure.functions.HttpMethod;
import com.microsoft.azure.functions.HttpRequestMessage;
import com.microsoft.azure.functions.HttpResponseMessage;
import com.microsoft.azure.functions.HttpStatus;
import com.microsoft.azure.functions.annotation.AuthorizationLevel;
import com.microsoft.azure.functions.annotation.FunctionName;
import com.microsoft.azure.functions.annotation.HttpTrigger;

import jakarta.inject.Inject;
import java.util.Optional;

public class Function {
    @Inject
    GreetingService service;

    @FunctionName("HttpExample")
    public HttpResponseMessage run(
            @HttpTrigger(
                name = "req",
                methods = {HttpMethod.GET, HttpMethod.POST},
                authLevel = AuthorizationLevel.ANONYMOUS)
                HttpRequestMessage<Optional<String>> request,
            final ExecutionContext context) {

        // Parse query parameter
        final String query = request.getQueryParameters().get("name");
        final String name = request.getBody().orElse(query);

        if (name == null) {
            return request.createResponseBuilder(HttpStatus.BAD_REQUEST).body("Please pass a name on the query string or in the request body").build();
        } else {
            return request.createResponseBuilder(HttpStatus.OK).body(service.greeting(name)).build();
        }
    }
}
----

== Prerequisites

include::{includes}/prerequisites.adoc[]
* link:https://azure.microsoft.com[A Microsoft Azure account]
+
[TIP]
====
If you don't have an existing Microsoft Azure subscription, you can create a free link:https://azure.microsoft.com/en-us/free/[Azure account].
====
+
* link:https://learn.microsoft.com/en-us/azure/azure-functions/functions-run-local#v2[Azure Functions Core Tools version 4.x] installed
* link:https://learn.microsoft.com/en-us/cli/azure/install-azure-cli[Azure CLI] installed

== Solution

By completing this tutorial, you will learn how to build and run a code project that can deploy an HTTP Trigger class on Azure Functions.
The HTTP Trigger function class provided in the example injects a CDI bean service that generates a greeting message that is passed back to the client.

:sectnums:
:sectnumlevels: 3

== Create the code deployment project

You can generate the example code `code-with-quarkus` project with the `quarkus-azure-functions-http` extension from the link:https://code.quarkus.io/d?e=azure-functions&cn=code.quarkus.io[Start coding with Quarkus] application generator web page.

Alternatively, you can use the xref:cli-tooling.adoc[Quarkus CLI] to generate the `code-with-quarkus` project that's needed for this tutorial:

:create-app-extensions: azure-functions
include::{includes}/devtools/create-app.adoc[]

[IMPORTANT]
====
When creating the Maven project, you must include the `quarkus-azure-functions` extension because this is the integration point between Quarkus and Azure Functions.
====

== Examining the project

If you open the build file of the generated project, for example, `pom.xml`, you'll see that the project is similar to any other Quarkus project.
The `quarkus-azure-functions` extension is the integration point between Quarkus and Azure Functions.
It registers a `callback`` function with the Azure Functions runtime to bootstrap Quarkus and to set up Quarkus/Arc as the function factory for your function classes.

[IMPORTANT]
====
From version 3.0, the `quarkus-azure-functions` extension no longer requires `azure-functions-maven-plugin` or an equivalent plugin.
Local development and Azure Functions packaging and deployment are now all done by Quarkus.
====

You can configure how your application builds in the Quarkus `application.properties` file.
The only required configuration switch is `quarkus.azure-functions.app-name`.


== Azure deployment descriptors

The Azure Functions `host.json` deployment descriptor gets automatically generated, but if you need to override it, declare it in the root directory of the project and rerun the build when you are ready.

You can find the templates for the Azure Functions deployment descriptors in the base directory of the project, for example, `host.json` and `function.json`.


== Log in to Microsoft Azure

If you don't log in to Azure you won't be able to deploy.

[source,bash,subs=attributes+]
----
az login
----

== Run the application within the Azure Functions local environment

[IMPORTANT]
====
You must have the link://https://learn.microsoft.com/en-us/azure/azure-functions/functions-run-local#v2[Azure Functions Core Tools]
installed.
====

If you want to try this example within the local Azure Functions environment, submit the following command:
[source,bash,subs=attributes+]
----
./mvnw quarkus:run
----

//Hiding Grade content until it is supported in this scenario. * Gradle:
//
//[source,bash,subs=attributes+]
//----
//./gradlew --info --no-daemon quarkusRun
//----

//[NOTE]
====
Gradle can be a bit quirky with process management, so you need the `--no-daemon` switch, otherwise when you press *Ctrl* + *C* the process does not end cleanly, resulting in open ports.
====

.Result

The URL to access the example would be:

/http://localhost:8081/api/hello


== Quarkus Integration Testing

You can implement integration tests by using `@QuarkusIntegrationTest` functionality, as follows:

[source,bash,subs=attributes+]
----
./mvnw -DskipITs=false verify
----

.Result
When these integration tests run, the local Azure Functions environment is spun up for the duration of integration testing.

To ensure that regular builds do not execute the test, always use the `*IT.java` file pattern.

//* For Gradle:
//[source,bash,subs=attributes+]
//----
//./gradlew --info quarkusIntTest
//----

//Make sure any integration tests you execute with Gradle are located within the `src/integrationTest/java` directory.
//Integration tests that exist in `src/test` will run with the regular build and fail.

== Deploy to Azure

The `quarkus-azure-functions-http` extension handles all of the work to deploy to Azure.
By default, Quarkus uses the Azure CLI in the background to authenticate and deploy to Azure.
If you have multiple subscriptions associated with your account, you must set the `quarkus.azure-functions.subscription-id` property in your `application.properties` file to the subscription you want to use.
For other authentication mechanisms and deployment options, see the link:https://quarkus.io/guides/all-config[Quarkus configuration properties] guide.

To run the deploy command, after you build your project, use the following command:

[source,bash,subs=attributes+]
----
./mvnw quarkus:deploy
----

//* For Gradle

//[source,bash,subs=attributes+]
//----
//./gradlew --info deploy
//----

== Access your function

When the deployment completes, Quarkus returns the endpoint of the example function to the console.

.Example

[source]
----
[INFO] HTTP Trigger Urls:
[INFO] 	 HttpExample : https://{appName}.azurewebsites.net/api/{*path}
----

//[NOTE]
====
For Gradle, you must use the `--info` switch to see this output.
====

In the example provided, the URL to access the service is:

\https://{appName}.azurewebsites.net/api/hello


:sectnums!:

== Summary

Congratulations!
You have learned how to create, build, and deploy a sample Quarkus application that includes an HTTP Trigger function to Microsoft Azure Functions by using Quarkus.

== References

* link:https://www.infoq.com/articles/azure-functions-quarkus/[Azure Functions in Quarkus 3]
* xref:azure-integration-built-in.adoc[Quarkus integration with Microsoft Azure]
* xref:azure-extensions-reference.adoc[Quarkus extensions for Azure integration]
* xref:deploying-to-azure-cloud.adoc[Deploy a Quarkus native executable to Microsoft Azure]
* xref:azure-functions-http.adoc[Integrate and deploy a RESTEasy Reactive endpoint to Azure Functions]
* xref:funqy-azure-functions-http.adoc[Funqy HTTP Binding with Azure Functions]
* link:https://learn.microsoft.com/en-us/azure/azure-functions/[Azure Functions]
* link:https://learn.microsoft.com/en-us/azure/azure-functions/functions-create-first-quarkus[Deploy serverless Java apps with Quarkus on Azure Functions]
